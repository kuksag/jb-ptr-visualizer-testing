# Random Access Container
## Тестовое задание для осенней практики JetBrains 2021 -- Визуализация указателей на локальные переменные в отладчике

### Обзор

В качестве задания предлагалось реализовать контейнер, поддерживающий три операции:
1) Вставка элемента
2) Удаление элемента
3) Получение элемента равновероятно среди всех остальных

Изначально было два подхода:

1) Реализовать аналог `std::vector` <br>
В этом случае достаточно легко мы можем выбрать равновероятно случайный элемент, так как 
все элементы в памяти лежат подряд, а также было бы относительно легко поддерживать гарантии исключениий, но трудности 
будут трудности с быстрой вставкой и удалением. 
   * `O(1)` на запрос случайного элемента
   * `O(n)` на удаление\добавление элемента
   * `O(n)` памяти на хранение
2) Реализовать древовидную структуру <br>
Это относительно немного сложнее реализовать технически, чем свой аналог вектора, и становится менее
тривиальным поиск случайного элемента, а также поддержка гарантии исключений, но взамен мы получаем быструю вставку и удаление.
   * `O(log n)` на запрос случайного элемента
   * `O(log n)` на удаление\добавление элемента
   * `O(n)` памяти на хранение
3) Поддержка hash-таблицы <br>
Самый простой с технической точки зрения вариант. Единственный минус в том, что ответ на запрос -- долгий.
    * `O(n)` на запрос случайного элемента
    * `O(1)` на удаление\добавление элемента
    * `O(n)` памяти на хранение

В решении был выбран варинт #2, так как он несет больший технический вызов.

### Реализация

#### Алгоритм

Чтобы поддерживать асимптотику на протяжении всего пользования структурой, было решено реализовывать [бинарное сбалансированное дерево](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree).  
Выбор был между декартовым деревом (ДД, [treap](https://en.wikipedia.org/wiki/Treap)) и [AVL-деревом](https://en.wikipedia.org/wiki/AVL_tree). 
Асимптотических отличий нет, константы при выполнениии операций меньше у AVL, но реализация намного более прозрачна у ДД, поэтому выбрано было именно оно.

#### Структура

Было реализовано два класса:
  * интерфейс ДД (`ITreap`), который включает в структуру вершину (`TNode`) и реализация `split\merge`
  * контейнер (`TRacont`, семантика: `Type: Random Acess Containter`), который включает в себя методы над интерфейсом `ITreap`


#### Детали реализации

* были использованы умные указатели
* в отличие от канонической реализации, в каждой вершине можно не хранить значение приоритета, а `merge` делать также недетерминированно, но в зависимости от размера деревьев. 
Есть теоретическая оценка, что это по-прежнему успешно балансирует дерево. В итоге получаем выигрыш по памяти.

### Тестирование

* Для тестов была использована библиотека [Doctest](https://github.com/onqtam/doctest)
* В качестве проверки качества когда использовались clang-format, clang-tidy, cppcheck
* В качестве проверки утечек памяти использовался Valgrind

#### Сборка

```shell
cmake .
make -j10 
./racont-test
```
